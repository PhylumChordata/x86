     1                                  ;Assembler: NASM
     2                                  ;
     3                                  ; *physical memory map*
     4                                  ;-----------------------
     5                                  ;-    ROM  (0.5 MB)    -
     6                                  ;-   0x80000-0xFFFFF   -
     7                                  ;-----------------------
     8                                  ;-    RAM  (0.5 MB)    -
     9                                  ;-   0x00000-0x7FFFF   -
    10                                  ;-----------------------
    11                                  ;
    12                                  ; To do:
    13                                  ;   -initialize interrupt vector table
    14                                  ;	-handlers, exceptions, hardware traps
    15                                  ;
    16                                  ; PPI/LCD code adapted from "The 80x86 IBM PC and Compatible Computers..., 4th Ed." -- Mazidi & Mazidi
    17                                  ; Sample interrupt code adapted from https://stackoverflow.com/questions/51693306/registering-interrupt-in-16-bit-x86-assembly
    18                                  ; Sample interrupt code adapted from "The 80x86 IBM PC and Compatible Computers..., 4th Ed." -- Mazidi & Mazidi
    19                                  ;
    20                                  
    21                                  cpu		286
    22                                  bits 	16
    23                                  
    24                                  section .data
    25                                  
    26                                  	;PPI1 (1602 LCD)						BUS_ADDR (BUS addresses are shifted one A2-->pin A1, A1-->pin A0)
    27                                  	;Base address: 0x00E0					11100000
    28                                  	;PPI1 pin values
    29                                  	;A1=0, A0=0		PORTA					11100000	0x00E0
    30                                  	;A1=0, A0=1		PORTB					11100010	0x00E2
    31                                  	;A1=1, A0=0		PORTC					11100100	0x00E4
    32                                  	;A1=1, A0=1		CONTROL REGISTER		11100110	0x00E6
    33                                  
    34                                  	PPI1_PORTA	equ	0x00E0
    35                                  	PPI1_PORTB	equ	0x00E2
    36                                  	PPI1_PORTC	equ 0x00E4
    37                                  	PPI1_CTL	equ	0x00E6
    38                                  	
    39                                  	
    40                                  	;PPI1 Configuration
    41                                  	;							1=I/O Mode	|	00=Mode 0	|	1=PA In		|	0=PC (upper 4) Out	|	0=Mode 0	|	0=PB Out	|	0=PC (lower 4) Out
    42                                  	CTL_CFG_PA_IN		equ		0b10010000		;0x90
    43                                  
    44                                  	;							1=I/O Mode	|	00=Mode 0	|	0=PA Out	|	0=PC (uppper 4) Out	|	0=Mode 0	|	0=PB Out	|	0=PC (lower 4) Out
    45                                  	CTL_CFG_PA_OUT		equ		0b10000000		;0x80
    46                                  	
    47                                  
    48                                  	RS	equ 0b00000001
    49                                  	RW 	equ 0b00000010
    50                                  	E 	equ 0b00000100
    51                                  
    52                                  	;Interrupt Controller
    53                                  	;Base address: 0x0010		;BUS_A1 connected to pin A0 of PIC
    54                                  	PICM_P0		equ	0x0010		;PIC Master Port 0		ICW1				OCW2, OCW2
    55                                  	PICM_P1		equ	0x0012		;PIC Master Port 1		ICW2, ICW3, ICW4	OCW1
    56                                  
    57                                  	KBD_BUFSIZE equ 32					; Keyboard Buffer length. Must be a power of 2
    58                                  	KBD_IVT_OFFSET equ 9*4				; Base address of keyboard interrupt (IRQ) in IVT  // 9*4=36=0x24
    59                                  										; Keyboard: IRQ1, INT number 0x09 (* 4 bytes per INT)
    60                                  
    61                                  
    62                                  section .bss
    63                                  section .text	;start=0x8000	;vstart=0x80000	;start=0x80000
    64                                  
    65                                  org		0x0000		;0x8000
    66                                  top:				; physically at 0x80000 in physical address space
    67                                  
    68                                  ;*** SETUP REGISTERS **********************************
    69 00080000 31C0                    xor		ax,	ax
    70 00080002 8ED8                    mov		ds, ax
    71 00080004 8EC0                    mov		es,	ax				; extra segment
    72 00080006 89C4                    mov		sp,	ax				; Start stack pointer at 0. It will wrap around (down) to FFFE.
    73 00080008 B84000                  mov		ax,	0x0040			; First 1K is reserved for interrupt vector table,
    74 0008000B 8ED0                    mov		ss,	ax				; Start stack segment at the end of the IVT.
    75                                  
    76                                  ;push 	cs 					; push CS onto the stack	
    77                                  ;pop 	ds 					; and pop it into DS so that DS is in ROM
    78                                  ;*** /SETUP REGISTERS *********************************
    79                                  
    80 0008000D FA                      cli					; disable interrupts
    81                                  
    82 0008000E E87A00                  call	lcd_init
    83 00080011 E84100                  call	print_message
    84 00080014 B0A8                    mov		al,		0b10101000	; Go to line 2
    85 00080016 E88700                  call	lcd_command_write
    86 00080019 B031                    mov		al,		'1'
    87 0008001B E89700                  call	lcd_data_write
    88                                  
    89                                  ;push 	cs 					; push CS onto the stack	
    90                                  ;pop 	ds 					; and pop it into DS so that DS is in ROM address space
    91                                  ;mov		bx,	string_test
    92                                  ;call	print_message2
    93                                  ;mov		ax,	0x0
    94                                  ;mov		ds, ax
    95                                  
    96                                  										; kbd_isr is at physical address 0x80047. The following few lines move segment 8000 and offset 0047 into the IVT
    97 0008001E C7062400[4B00]          mov word [KBD_IVT_OFFSET], kbd_isr		; DS set to 0x0000 above. These MOVs are relative to DS.
    98                                  										; 0x0000:0x0024 = IRQ1 offset in IVT
    99 00080024 B80080                  mov		ax, 0x8000
   100 00080027 A32600                  mov word [KBD_IVT_OFFSET+2], ax			; 0x0000:0x0026 = IRQ1 segment in IVT
   101                                  
   102                                  								; ICW1: 0001 | LTIM (1=level, 0=edge) | 0 | SNGL (1=single, 0=cascade) | IC4 (1=needed, 0=not)
   103 0008002A B013                    mov		al,			0b00010011			;0x13		ICW1 - edge, master, ICW4
   104 0008002C E610                    out		PICM_P0,	al
   105                                  
   106                                  								; ICW2: Interrupt assigned to IR0 of the 8259 (usually 0x08)
   107 0008002E B008                    mov		al,			0x08		; setup ICW2 - interrupt type 8 (8-F)
   108 00080030 E612                    out		PICM_P1,	al
   109                                  
   110                                  								; ICW3: 1=IR input has a slave, 0=no slave
   111 00080032 B000                    mov		al,			0x00		; setup ICW3 - no slaves
   112 00080034 E612                    out		PICM_P1,	al
   113                                  
   114                                  								; ICW4: 000 | SFNM (1=spec fully nested mode, 0=not) | BUF & MS (0x = nonbuffered, 10 = buffered slave, 11 = buffered master) 
   115                                  								; | AEOI (1=auto EOI, 0=normal) | PM (1=x86,0=8085)
   116 00080036 B001                    mov		al,			0x01		; setup ICW4 - master x86 mode
   117 00080038 E612                    out		PICM_P1,	al
   118                                  
   119                                  								; OCW1: For bits, 0=unmask (enable interrupt), 1=mask
   120 0008003A B000                    mov		al,			0b00000000	; Unmask IR0-IR7
   121 0008003C E612                    out		PICM_P1,	al
   122                                  
   123 0008003E B032                    mov		al,		'2'
   124 00080040 E87200                  call	lcd_data_write
   125                                  
   126 00080043 FB                      sti										; Enable interrupts
   127                                  
   128 00080044 B033                    mov		al,		'3'
   129 00080046 E86C00                  call	lcd_data_write
   130                                  
   131                                  .main_loop:
   132 00080049 EBFE                    	jmp .main_loop
   133                                  
   134                                  kbd_isr:
   135                                  	;to do save registers
   136                                  
   137                                  	;do stuff
   138 0008004B B021                    	mov		al,		'!'			;**not getting here
   139 0008004D E86500                  	call	lcd_data_write
   140                                  
   141                                  	
   142                                  	;to do restore registers
   143 00080050 B020                    	mov		al,			0x20		; EOI byte for OCW2 (always 0x20)
   144 00080052 E610                    	out		PICM_P0,	al			; to port for OCW2
   145 00080054 CF                      	iret
   146                                  
   147                                  print_message:
   148 00080055 B052                    	mov		al,		'R'
   149 00080057 E85B00                  	call	lcd_data_write
   150 0008005A B065                    	mov		al,		'e'
   151 0008005C E85600                  	call	lcd_data_write
   152 0008005F B061                    	mov		al,		'a'
   153 00080061 E85100                  	call	lcd_data_write
   154 00080064 B064                    	mov		al,		'd'
   155 00080066 E84C00                  	call	lcd_data_write
   156 00080069 B079                    	mov		al,		'y'
   157 0008006B E84700                  	call	lcd_data_write
   158 0008006E B03E                    	mov		al,		'>'
   159 00080070 E84200                  	call	lcd_data_write
   160 00080073 C3                      	ret
   161                                  
   162                                  print_message2:
   163                                  	; Send a NUL-terminated string to the LCD display;
   164                                  	; In: DS:BX -> string to print
   165                                  	; Return: AX = number of characters printed
   166                                  	; All other registers preserved or unaffected.
   167                                  	; **thank you, Damouze!
   168                                  
   169                                  
   170                                  
   171 00080074 53                      	push	bx 					; Save BX 
   172 00080075 51                      	push	cx 					; and CX onto the sack
   173 00080076 89D9                    	mov		cx, bx 				; Save contents of BX for later use
   174                                  	
   175                                  	.loop:
   176 00080078 8A07                    		mov		al, [bx] 		; Read byte from [DS:BX]
   177 0008007A 08C0                    		or		al, al 			; Did we encounter a NUL character?
   178 0008007C 7406                    		jz		.return 		; If so, return to the caller
   179 0008007E E83400                  		call	lcd_data_write 	; call our character print routine
   180 00080081 43                      		inc		bx 				; Increment the index
   181 00080082 EBF4                    		jmp		.loop 			; And loop back
   182                                  	
   183                                  	.return: 
   184 00080084 29CB                    		sub		bx, cx 			; Calculate our number of characters printed
   185 00080086 89D8                    		mov		ax, bx 			; And load the result into AX
   186 00080088 59                      		pop		cx 				; Restore CX
   187 00080089 5B                      		pop		bx 				; and BX from the stack
   188 0008008A C3                      		ret 					; Return to our caller
   189                                  
   190                                  lcd_init:
   191 0008008B B038                    	mov		al,		0b00111000	;0x38	; Set to 8-bit mode, 2 lines, 5x7 font
   192 0008008D E81000                  	call	lcd_command_write
   193 00080090 B00E                    	mov		al,		0b00001110	;0x0E	; LCD on, cursor on, blink off
   194 00080092 E80B00                  	call	lcd_command_write
   195 00080095 B001                    	mov		al,		0b00000001	;0x01	; clear LCD
   196 00080097 E80600                  	call	lcd_command_write
   197 0008009A B006                    	mov		al,		0b00000110  ;0x06	; increment and shift cursor, don't shift display
   198 0008009C E80100                  	call	lcd_command_write
   199 0008009F C3                      	ret
   200                                  
   201                                  lcd_command_write:
   202 000800A0 E82700                  	call	lcd_wait
   203 000800A3 52                      	push	dx
   204 000800A4 BAE000                  	mov		dx,		PPI1_PORTA			; Get A port address
   205 000800A7 EE                      	out		dx,		al					; Send al to port A
   206 000800A8 BAE200                  	mov		dx,		PPI1_PORTB			; Get B port address
   207 000800AB B004                    	mov		al,		E					; RS=0, RW=0, E=1
   208 000800AD EE                      	out		dx,		al					; Write to port B
   209 000800AE 90                      	nop									; wait for high-to-low pulse to be wide enough
   210 000800AF 90                      	nop
   211 000800B0 B000                    	mov		al,		0x0					; RS=0, RW=0, E=0
   212 000800B2 EE                      	out		dx,		al					; Write to port B
   213 000800B3 5A                      	pop		dx
   214 000800B4 C3                      	ret
   215                                  
   216                                  lcd_data_write:
   217 000800B5 E81200                  	call	lcd_wait
   218 000800B8 52                      	push	dx
   219 000800B9 BAE000                  	mov		dx,		PPI1_PORTA			; Get A port address
   220 000800BC EE                      	out		dx,		al					; Write data (e.g. char) to port A
   221 000800BD B005                    	mov		al,		(RS | E)			; RS=1, RW=0, E=1
   222 000800BF BAE200                  	mov		dx,		PPI1_PORTB			; Get B port address
   223 000800C2 EE                      	out		dx,		al					; Write to port B - enable high
   224 000800C3 90                      	nop									; wait for high-to-low pulse to be wide enough
   225 000800C4 90                      	nop
   226 000800C5 B001                    	mov		al,		RS					; RS=1, RW=0, E=0
   227 000800C7 EE                      	out		dx,		al					; Write to port B - enable low
   228 000800C8 5A                      	pop		dx
   229 000800C9 C3                      	ret
   230                                  
   231                                  lcd_wait:
   232 000800CA 50                      	push	ax				
   233 000800CB 52                      	push	dx
   234 000800CC B090                    	mov		al,		CTL_CFG_PA_IN		; Get config value
   235 000800CE BAE600                  	mov		dx,		PPI1_CTL			; Get control port address
   236 000800D1 EE                      	out		dx,		al					; Write control register on PPI
   237                                  
   238                                  	.again:	
   239 000800D2 B002                    		mov		al,		(RW)				; RS=0, RW=1, E=0
   240 000800D4 BAE200                  		mov		dx,		PPI1_PORTB			; Get B port address
   241 000800D7 EE                      		out		dx,		al					; Write to port B
   242 000800D8 B006                    		mov		al,		(RW|E)				; RS=0, RW=1, E=1
   243 000800DA EE                      		out		dx,		al					; Write to port B
   244                                  	
   245 000800DB BAE000                  		mov		dx,		PPI1_PORTA			; Get A port address
   246                                  
   247 000800DE EC                      		in		al,		dx				; Read data from LCD (busy flag on D7)
   248 000800DF D0C0                    		rol		al,		1				; Rotate busy flag to carry flag
   249 000800E1 72EF                    		jc		.again					; If CF=1, LCD is busy
   250 000800E3 B080                    		mov		al,		CTL_CFG_PA_OUT	; Get config value
   251 000800E5 BAE600                  		mov		dx,		PPI1_CTL		; Get control port address
   252 000800E8 EE                      		out		dx,		al				; Write control register on PPI
   253                                  
   254 000800E9 5A                      	pop	dx
   255 000800EA 58                      	pop	ax
   256 000800EB C3                      	ret
   257                                  
   258                                  delay:
   259 000800EC 60                      	pusha
   260 000800ED BD0000                  	mov		bp, 0x0000
   261 000800F0 BE0100                  	mov		si, 0x0001
   262                                  	.delay2:
   263 000800F3 4D                      		dec		bp
   264 000800F4 90                      		nop
   265 000800F5 75FC                    		jnz		.delay2
   266 000800F7 4E                      		dec		si
   267 000800F8 83FE00                  		cmp		si,0    
   268 000800FB 75F6                    		jnz		.delay2
   269 000800FD 61                      	popa
   270 000800FE C3                      	ret
   271                                  
   272 000800FF 383032383620617420-     string_test db '80286 at 8 MHz!', 0x0
   272 00080108 38204D487A2100     
   273                                  
   274                                  ;***********************************************************************************************
   275 0008010F 90<rep 7FEE1h>          times 0x7fff0-($-$$) nop	;Fill ROM with NOPs up to startup address
   276                                  							;This will get to 0xFFFF0 
   277                                  
   278                                  reset:						;at 0xFFFF0			*Processor starts reading here
   279 000FFFF0 EA00000080              	jmp 0x8000:0x0				;EA	00 00 00 80		Jump to TOP: label
   280                                  
   281 000FFFF5 01<rep Bh>              times 0x080000-($-$$) db 1	;Fill the rest of ROM with bytes of 0x01 (512 KB total)
