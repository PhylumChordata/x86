     1                                  ;Assembler: NASM
     2                                  ;
     3                                  ; *physical memory map*
     4                                  ;-----------------------
     5                                  ;-    ROM  (0.5 MB)    -
     6                                  ;-   0x80000-0xFFFFF   -
     7                                  ;-----------------------
     8                                  ;-    RAM  (0.5 MB)    -
     9                                  ;-   0x00000-0x7FFFF   -
    10                                  ;-----------------------
    11                                  ;
    12                                  ; To do:
    13                                  ;   -initialize interrupt vector table
    14                                  ;	-handlers, exceptions, hardware traps
    15                                  ;
    16                                  ; PPI/LCD code adapted from "The 80x86 IBM PC and Compatible Computers..., 4th Ed." -- Mazidi & Mazidi
    17                                  ; Sample interrupt code adapted from https://stackoverflow.com/questions/51693306/registering-interrupt-in-16-bit-x86-assembly
    18                                  ; Sample interrupt code adapted from "The 80x86 IBM PC and Compatible Computers..., 4th Ed." -- Mazidi & Mazidi
    19                                  ;
    20                                  
    21                                  cpu		286
    22                                  bits 	16
    23                                  
    24                                  section .data
    25                                  
    26                                  	;PPI1 (1602 LCD)						BUS_ADDR (BUS addresses are shifted one A2-->pin A1, A1-->pin A0)
    27                                  	;Base address: 0x00E0					11100000
    28                                  	;PPI1 pin values
    29                                  	;A1=0, A0=0		PORTA					11100000	0x00E0
    30                                  	;A1=0, A0=1		PORTB					11100010	0x00E2
    31                                  	;A1=1, A0=0		PORTC					11100100	0x00E4
    32                                  	;A1=1, A0=1		CONTROL REGISTER		11100110	0x00E6
    33                                  
    34                                  	PPI1_PORTA	equ	0x00E0
    35                                  	PPI1_PORTB	equ	0x00E2
    36                                  	PPI1_PORTC	equ 0x00E4
    37                                  	PPI1_CTL	equ	0x00E6
    38                                  	
    39                                  	
    40                                  	;PPI1 Configuration
    41                                  	;							1=I/O Mode	|	00=Mode 0	|	1=PA In		|	0=PC (upper 4) Out	|	0=Mode 0	|	0=PB Out	|	0=PC (lower 4) Out
    42                                  	CTL_CFG_PA_IN		equ		0b10010000		;0x90
    43                                  
    44                                  	;							1=I/O Mode	|	00=Mode 0	|	0=PA Out	|	0=PC (uppper 4) Out	|	0=Mode 0	|	0=PB Out	|	0=PC (lower 4) Out
    45                                  	CTL_CFG_PA_OUT		equ		0b10000000		;0x80
    46                                  	
    47                                  
    48                                  	RS	equ 0b00000001
    49                                  	RW 	equ 0b00000010
    50                                  	E 	equ 0b00000100
    51                                  
    52                                  	;Interrupt Controller
    53                                  	;Base address: 0x0010		;BUS_A1 connected to pin A0 of PIC
    54                                  	PICM_P0		equ	0x0010		;PIC Master Port 0		ICW1				OCW2, OCW2
    55                                  	PICM_P1		equ	0x0012		;PIC Master Port 1		ICW2, ICW3, ICW4	OCW1
    56                                  
    57                                  	KBD_BUFSIZE equ 32					; Keyboard Buffer length. Must be a power of 2
    58                                  	KBD_IVT_OFFSET equ 9*4				; Base address of keyboard interrupt (IRQ) in IVT  // 9*4=36=0x24
    59                                  										; Keyboard: IRQ1, INT number 0x09 (* 4 bytes per INT)
    60                                  
    61                                  
    62                                  section .bss
    63                                  section .text	;start=0x8000	;vstart=0x80000	;start=0x80000
    64                                  
    65                                  org		0x0000		;0x8000
    66                                  top:				; physically at 0x80000 in physical address space
    67                                  
    68                                  ;*** SETUP REGISTERS **********************************
    69 00080000 31C0                    xor		ax,	ax
    70 00080002 8ED8                    mov		ds, ax
    71 00080004 8EC0                    mov		es,	ax				; extra segment
    72 00080006 89C4                    mov		sp,	ax				; Start stack pointer at 0. It will wrap around (down) to FFFE.
    73 00080008 B84000                  mov		ax,	0x0040			; First 1K is reserved for interrupt vector table,
    74 0008000B 8ED0                    mov		ss,	ax				; Start stack segment at the end of the IVT.
    75                                  
    76                                  ;push 	cs 					; push CS onto the stack	
    77                                  ;pop 	ds 					; and pop it into DS so that DS is in ROM
    78                                  ;*** /SETUP REGISTERS *********************************
    79                                  
    80 0008000D FA                      cli					; disable interrupts
    81                                  
    82 0008000E E87600                  call	lcd_init
    83 00080011 E83D00                  call	print_message
    84 00080014 B0A8                    mov		al,		0b10101000	; Go to line 2
    85 00080016 E88300                  call	lcd_command_write
    86 00080019 B031                    mov		al,		'1'
    87 0008001B E89300                  call	lcd_data_write
    88                                  
    89                                  ;push 	cs 					; push CS onto the stack	
    90                                  ;pop 	ds 					; and pop it into DS so that DS is in ROM address space
    91                                  ;mov		bx,	string_test
    92                                  ;call	print_message2
    93                                  ;mov		ax,	0x0
    94                                  ;mov		ds, ax
    95                                  
    96                                  										; kbd_isr is at physical address 0x80047. The following few lines move segment 8000 and offset 0047 into the IVT
    97 0008001E C7062400[4700]          mov word [KBD_IVT_OFFSET], kbd_isr		; DS set to 0x0000 above. These MOVs are relative to DS.
    98                                  										; 0x0000:0x0024 = IRQ1 offset in IVT
    99 00080024 B80080                  mov		ax, 0x8000
   100 00080027 A32600                  mov word [KBD_IVT_OFFSET+2], ax			; 0x0000:0x0026 = IRQ1 segment in IVT
   101                                  
   102                                  								; ICW1: 0001 | LTIM (1=level, 0=edge) | 0 | SNGL (1=single, 0=cascade) | IC4 (1=needed, 0=not)
   103 0008002A B013                    mov		al,			0b00010011			;0x13		ICW1 - edge, master, ICW4
   104 0008002C E610                    out		PICM_P0,	al
   105                                  
   106                                  								; ICW2: Interrupt assigned to IR0 of the 8259 (usually 0x08)
   107 0008002E B008                    mov		al,			0x08		; setup ICW2 - interrupt type 8 (8-F)
   108 00080030 E612                    out		PICM_P1,	al
   109                                  
   110                                  								; ICW3: 1=IR input has a slave, 0=no slave			--only set if using master/slave (SNGL=0 in ICW1)
   111                                  ;mov		al,			0x00		; setup ICW3 - no slaves
   112                                  ;out		PICM_P1,	al
   113                                  
   114                                  								; ICW4: 000 | SFNM (1=spec fully nested mode, 0=not) | BUF & MS (0x = nonbuffered, 10 = buffered slave, 11 = buffered master) 
   115                                  								; | AEOI (1=auto EOI, 0=normal) | PM (1=x86,0=8085)
   116 00080032 B001                    mov		al,			0x01		; setup ICW4 - master x86 mode
   117 00080034 E612                    out		PICM_P1,	al
   118                                  
   119                                  								; OCW1: For bits, 0=unmask (enable interrupt), 1=mask
   120 00080036 B000                    mov		al,			0b00000000	; Unmask IR0-IR7
   121 00080038 E612                    out		PICM_P1,	al
   122                                  
   123 0008003A B032                    mov		al,		'2'
   124 0008003C E87200                  call	lcd_data_write
   125                                  
   126 0008003F FB                      sti										; Enable interrupts
   127                                  
   128 00080040 B033                    mov		al,		'3'
   129 00080042 E86C00                  call	lcd_data_write
   130                                  
   131                                  .main_loop:
   132 00080045 EBFE                    	jmp .main_loop
   133                                  
   134                                  kbd_isr:
   135                                  	;to do save registers
   136                                  
   137                                  	;do stuff
   138 00080047 B021                    	mov		al,		'!'			;**not getting here
   139 00080049 E86500                  	call	lcd_data_write
   140                                  
   141                                  	
   142                                  	;to do restore registers
   143 0008004C B020                    	mov		al,			0x20		; EOI byte for OCW2 (always 0x20)
   144 0008004E E610                    	out		PICM_P0,	al			; to port for OCW2
   145 00080050 CF                      	iret
   146                                  
   147                                  print_message:
   148 00080051 B052                    	mov		al,		'R'
   149 00080053 E85B00                  	call	lcd_data_write
   150 00080056 B065                    	mov		al,		'e'
   151 00080058 E85600                  	call	lcd_data_write
   152 0008005B B061                    	mov		al,		'a'
   153 0008005D E85100                  	call	lcd_data_write
   154 00080060 B064                    	mov		al,		'd'
   155 00080062 E84C00                  	call	lcd_data_write
   156 00080065 B079                    	mov		al,		'y'
   157 00080067 E84700                  	call	lcd_data_write
   158 0008006A B03E                    	mov		al,		'>'
   159 0008006C E84200                  	call	lcd_data_write
   160 0008006F C3                      	ret
   161                                  
   162                                  print_message2:
   163                                  	; Send a NUL-terminated string to the LCD display;
   164                                  	; In: DS:BX -> string to print
   165                                  	; Return: AX = number of characters printed
   166                                  	; All other registers preserved or unaffected.
   167                                  	; **thank you, Damouze!
   168                                  
   169                                  
   170                                  
   171 00080070 53                      	push	bx 					; Save BX 
   172 00080071 51                      	push	cx 					; and CX onto the sack
   173 00080072 89D9                    	mov		cx, bx 				; Save contents of BX for later use
   174                                  	
   175                                  	.loop:
   176 00080074 8A07                    		mov		al, [bx] 		; Read byte from [DS:BX]
   177 00080076 08C0                    		or		al, al 			; Did we encounter a NUL character?
   178 00080078 7406                    		jz		.return 		; If so, return to the caller
   179 0008007A E83400                  		call	lcd_data_write 	; call our character print routine
   180 0008007D 43                      		inc		bx 				; Increment the index
   181 0008007E EBF4                    		jmp		.loop 			; And loop back
   182                                  	
   183                                  	.return: 
   184 00080080 29CB                    		sub		bx, cx 			; Calculate our number of characters printed
   185 00080082 89D8                    		mov		ax, bx 			; And load the result into AX
   186 00080084 59                      		pop		cx 				; Restore CX
   187 00080085 5B                      		pop		bx 				; and BX from the stack
   188 00080086 C3                      		ret 					; Return to our caller
   189                                  
   190                                  lcd_init:
   191 00080087 B038                    	mov		al,		0b00111000	;0x38	; Set to 8-bit mode, 2 lines, 5x7 font
   192 00080089 E81000                  	call	lcd_command_write
   193 0008008C B00E                    	mov		al,		0b00001110	;0x0E	; LCD on, cursor on, blink off
   194 0008008E E80B00                  	call	lcd_command_write
   195 00080091 B001                    	mov		al,		0b00000001	;0x01	; clear LCD
   196 00080093 E80600                  	call	lcd_command_write
   197 00080096 B006                    	mov		al,		0b00000110  ;0x06	; increment and shift cursor, don't shift display
   198 00080098 E80100                  	call	lcd_command_write
   199 0008009B C3                      	ret
   200                                  
   201                                  lcd_command_write:
   202 0008009C E82700                  	call	lcd_wait
   203 0008009F 52                      	push	dx
   204 000800A0 BAE000                  	mov		dx,		PPI1_PORTA			; Get A port address
   205 000800A3 EE                      	out		dx,		al					; Send al to port A
   206 000800A4 BAE200                  	mov		dx,		PPI1_PORTB			; Get B port address
   207 000800A7 B004                    	mov		al,		E					; RS=0, RW=0, E=1
   208 000800A9 EE                      	out		dx,		al					; Write to port B
   209 000800AA 90                      	nop									; wait for high-to-low pulse to be wide enough
   210 000800AB 90                      	nop
   211 000800AC B000                    	mov		al,		0x0					; RS=0, RW=0, E=0
   212 000800AE EE                      	out		dx,		al					; Write to port B
   213 000800AF 5A                      	pop		dx
   214 000800B0 C3                      	ret
   215                                  
   216                                  lcd_data_write:
   217 000800B1 E81200                  	call	lcd_wait
   218 000800B4 52                      	push	dx
   219 000800B5 BAE000                  	mov		dx,		PPI1_PORTA			; Get A port address
   220 000800B8 EE                      	out		dx,		al					; Write data (e.g. char) to port A
   221 000800B9 B005                    	mov		al,		(RS | E)			; RS=1, RW=0, E=1
   222 000800BB BAE200                  	mov		dx,		PPI1_PORTB			; Get B port address
   223 000800BE EE                      	out		dx,		al					; Write to port B - enable high
   224 000800BF 90                      	nop									; wait for high-to-low pulse to be wide enough
   225 000800C0 90                      	nop
   226 000800C1 B001                    	mov		al,		RS					; RS=1, RW=0, E=0
   227 000800C3 EE                      	out		dx,		al					; Write to port B - enable low
   228 000800C4 5A                      	pop		dx
   229 000800C5 C3                      	ret
   230                                  
   231                                  lcd_wait:
   232 000800C6 50                      	push	ax				
   233 000800C7 52                      	push	dx
   234 000800C8 B090                    	mov		al,		CTL_CFG_PA_IN		; Get config value
   235 000800CA BAE600                  	mov		dx,		PPI1_CTL			; Get control port address
   236 000800CD EE                      	out		dx,		al					; Write control register on PPI
   237                                  
   238                                  	.again:	
   239 000800CE B002                    		mov		al,		(RW)				; RS=0, RW=1, E=0
   240 000800D0 BAE200                  		mov		dx,		PPI1_PORTB			; Get B port address
   241 000800D3 EE                      		out		dx,		al					; Write to port B
   242 000800D4 B006                    		mov		al,		(RW|E)				; RS=0, RW=1, E=1
   243 000800D6 EE                      		out		dx,		al					; Write to port B
   244                                  	
   245 000800D7 BAE000                  		mov		dx,		PPI1_PORTA			; Get A port address
   246                                  
   247 000800DA EC                      		in		al,		dx				; Read data from LCD (busy flag on D7)
   248 000800DB D0C0                    		rol		al,		1				; Rotate busy flag to carry flag
   249 000800DD 72EF                    		jc		.again					; If CF=1, LCD is busy
   250 000800DF B080                    		mov		al,		CTL_CFG_PA_OUT	; Get config value
   251 000800E1 BAE600                  		mov		dx,		PPI1_CTL		; Get control port address
   252 000800E4 EE                      		out		dx,		al				; Write control register on PPI
   253                                  
   254 000800E5 5A                      	pop	dx
   255 000800E6 58                      	pop	ax
   256 000800E7 C3                      	ret
   257                                  
   258                                  delay:
   259 000800E8 60                      	pusha
   260 000800E9 BD0000                  	mov		bp, 0x0000
   261 000800EC BE0100                  	mov		si, 0x0001
   262                                  	.delay2:
   263 000800EF 4D                      		dec		bp
   264 000800F0 90                      		nop
   265 000800F1 75FC                    		jnz		.delay2
   266 000800F3 4E                      		dec		si
   267 000800F4 83FE00                  		cmp		si,0    
   268 000800F7 75F6                    		jnz		.delay2
   269 000800F9 61                      	popa
   270 000800FA C3                      	ret
   271                                  
   272 000800FB 383032383620617420-     string_test db '80286 at 8 MHz!', 0x0
   272 00080104 38204D487A2100     
   273                                  
   274                                  ;***********************************************************************************************
   275 0008010B 90<rep 7FEE5h>          times 0x7fff0-($-$$) nop	;Fill ROM with NOPs up to startup address
   276                                  							;This will get to 0xFFFF0 
   277                                  
   278                                  reset:						;at 0xFFFF0			*Processor starts reading here
   279 000FFFF0 EA00000080              	jmp 0x8000:0x0				;EA	00 00 00 80		Jump to TOP: label
   280                                  
   281 000FFFF5 01<rep Bh>              times 0x080000-($-$$) db 1	;Fill the rest of ROM with bytes of 0x01 (512 KB total)
